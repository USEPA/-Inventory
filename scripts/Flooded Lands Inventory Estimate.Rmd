---
title: "Flooded Lands Inventory Estimate"
author: "J. Beaulieu"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
    fig_caption: yes
    depth: 2
    number_sections: true
    code_folding:  hide
editor_options: 
  chunk_output_type: console
---

## Setup

Load libraries and print session info to facilitate reproducibility.
```{r setup, message=FALSE, warning=FALSE}
# increase java memory for writing to excel
# This must be run before any packages are loaded.  If workspace is loaded when
# project is opended, then this command won't work and loadWorkbook() will 
# fail.  Must populate working environment from scratch every session.
#https://stackoverflow.com/questions/21937640/handling-java-lang-outofmemoryerror-when-writing-to-excel-from-r
#https://stackoverflow.com/questions/27153974/how-to-fix-outofmemoryerror-java-gc-overhead-limit-exceeded-in-r

options(java.parameters = "-Xmx1024m") #"-Xmx1024m" worked once

library(tidyverse)
library(sf)
library(USAboundaries)
library(lwgeom)
library(xlsx)
library(cowplot)

library(conflicted) # manage MASS::select and dplyr::select conflict
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")


# Print R session info
print(sessionInfo())
```


## Flooded Lands Data Sources
Flooded Lands in the US are derived from the [U.S. Army Corps of Engineers National Inventory of Dams](https://nid.sec.usace.army.mil/ords/f?p=105:1::::::), Navigable Waterways dataset maintained by the Department of Homeland security, and the [National Hydrography Data (NHD)](https://www.usgs.gov/core-science-systems/ngp/national-hydrography) maintained by the USGS.  Several screening tools were used to discriminate natural water bodies from Flooded Lands in these data sets.


Below we read in the layers created by Alex.  Layers are then combined into a single sf object.  A simple check shows that all rows were preserved in the merge.

```{r, message=FALSE, warning=FALSE, results="hide"}

#  read data from local sources
# from US_Flooded_Lands.gdb provided by Hall on 8/26/2021
# Inundation areas
inund <- sf::st_read(paste0("C:\\Users\\JBEAULIE\\Environmental Protection Agency (EPA)\\",
                            "SuRGE Survey of Reservoir Greenhouse gas Emissions - Documents\\",
                            "surgeDsn\\nationalFloodedLandsMapping\\Reservoir Data\\US_Flooded_Lands.gdb"),
                     layer = "Inundation_Areas") %>%
  st_transform(5070) # Conus Albers for mapping and area calculations

# Navigable waterways
nav <- sf::st_read(paste0("C:\\Users\\JBEAULIE\\Environmental Protection Agency (EPA)\\",
                          "SuRGE Survey of Reservoir Greenhouse gas Emissions - Documents\\",
                          "surgeDsn\\nationalFloodedLandsMapping\\Reservoir Data\\US_Flooded_Lands.gdb"),
                   layer = "Navigable_Waterways_Update") %>%
  st_transform(5070) # Conus Albers for mapping and area calculations


# Reservoirs
res <- sf::st_read(paste0("C:\\Users\\JBEAULIE\\Environmental Protection Agency (EPA)\\",
                          "SuRGE Survey of Reservoir Greenhouse gas Emissions - Documents\\",
                          "surgeDsn\\nationalFloodedLandsMapping\\Reservoir Data\\US_Flooded_Lands.gdb"),
                   layer = "Reservoirs_Update") %>%
  st_transform(5070) # Conus Albers for mapping and area calculations

# Canals and ditches
canals <- sf::st_read(paste0("C:\\Users\\JBEAULIE\\Environmental Protection Agency (EPA)\\",
                          "SuRGE Survey of Reservoir Greenhouse gas Emissions - Documents\\",
                          "surgeDsn\\nationalFloodedLandsMapping\\Reservoir Data\\US_Flooded_Lands.gdb"),
                   layer = "Canal_Ditches") %>%
  st_transform(5070) # Conus Albers for mapping and area calculations

# Total number of observations
nrow(inund) + nrow(nav) + nrow(res) + nrow(canals) #55,073

# combine spatial data object
fl.sf <- dplyr::bind_rows(nav, inund, res, canals) 
nrow(fl.sf) #55073, all observations retained
st_crs(fl.sf) # 5070, Conus Albers for mapping and area calculations
```

## Flooded Lands By State
Area is represented in a few different variables in the merged data object.  For consistency, area is recalculated for all polygons.  However, we also need to partition polygon area between states.  This is straightforward for polygons contained entirely within a state, but more complicated for intrastate polygons such as Mississippi River Pool 8 which crosses three state boundaries.  We need to preserve the original polygon area to choose the appropriate emission factor (pond vs reservoir), but need the state specific area for summing across states.  Same consideration when we intersect polygons with climate map.
```{r, message=FALSE, warning=FALSE, results="hide"}
# This object represents area in quite a few ways.  This probably reflects
# the diversity of data sources merged to create this object.  
names(fl.sf)[grepl(pattern = "are", x = names(fl.sf), ignore.case = TRUE)] # 12 different permutations!

# Recalculate area and assign to new variable
# This will represent area of original polygon, prior to be broken up by state 
# and/or climate.  # This should be used to determine emission factor (pond vs reservoir). 
fl.sf$area_ha_original <- st_area(fl.sf) %>% units::set_units(., ha) # get in hectares
# compare recalculated and imported area values
fl.sf %>% filter(COMID == 13335116) %>% # grab Mississippi Pool 8 
  select(area_ha_original, Are_ha) # great, nearly identical results.  Differences
# may be due to projection changes (Albers used here)

# remove other area related variables for simplicity.
# All names with 'are';  one area field is 'Are_ha'
area_names <- names(fl.sf)[grepl(pattern = "are", x = names(fl.sf), ignore.case = TRUE)] 
area_names <- area_names[!(area_names == "area_ha_original")] # want to keep 'area_ha_original'
fl.sf <- fl.sf %>% select(-all_of(area_names))


# add state identifier to each waterbody.  Polygons that cross state boundaries
# will be split into multipart polygons.  Inspect an intrastate polygon (pool 8)
# before breaking into state specific section.
fl.sf %>% filter(COMID == 13335116) # just one row
fl.sf %>% filter(COMID == 13335116) %>% plot(., max.plot = 1) # preview geometry

# get state boundary
us <- us_states() %>% # get states map
  st_transform(crs = 5070) # 5070, as above

# Now intersect with state
fl.sf <- sf::st_intersection(x = fl.sf, y = us)

# Lets see what happened to Pool 8 polygon after intersecting with state
fl.sf %>% filter(COMID == 13335116) # now we have three rows, one for each state
fl.sf %>% filter(COMID == 13335116) %>% plot(., max.plot = 1) # overall geometry unchanged
fl.sf %>% filter(COMID == 13335116) %>% select(name) %>% plot() # but we can see polygon by state!


# Now that polygon is split by state, we need to recalculate area, but first,
# lets intersect with climate which will further split up polygons.  See next section

```

## Flooded Lands Climate Zone
IPCC emission factors are aggregated into six climate zones.  Below we assign aggregated climate zone classification to each polygon.  The original 12 IPCC climate zones were aggregated per Table 7A.2 in Lovelock et al. Flooded Lands Methodology.  See C:\Users\JBEAULIE\OneDrive - Environmental Protection Agency (EPA)\Profile\Documents\Documents\research\IPCC\methodology2019\methodology2019.Rproj for details.

```{r}
climate <- sf::st_read("inputData/climateMap", layer = "ipcc_zones_2017_names_dissolve") %>%
  select(fldd_zn) %>% # pull out Flooded Lands climate zone
  rename(climate = fldd_zn) %>% # rename
   st_transform(5070) # consistent with above

plot(climate)

# As with state, climate zones may further bisect polygons.  For example, COMID 120049697
# is a Mississippi River impoundment spanning Iowa, Illinois, and Wisconsin.  It is also bisected by the
# cool temperate and warm temperate moist climate zones.  Preview it now, then
# see what happens after intersecting with climate
fl.sf %>% filter(COMID == 120049697)

# Add Flooded Lands climate zone info to each lake polygon
fl.sf.c <- sf::st_intersection(x = fl.sf, y = climate)

# ok, the intersection further divided the polygons.  Note that we don't yet
# have an area estimate for the subdivided polygons.  That is coming below.
fl.sf.c %>% filter(COMID == 120049697)
```

## Flooded Lands Area

We calculated area of the original polygons (area_ha_original), but these polygons were split up by the intersection with state and climate.  Need to recalculate polygons areas.

```{r}
# Calculate area
fl.sf.c$area_ha_new <- st_area(fl.sf.c) %>% units::set_units(., ha) # get in hectares

# compare area_ha_original and area_ha_new
fl.sf.c %>% filter(COMID == 13335116) %>% # grab Mississippi Pool 8 
  select(name, area_ha_original, area_ha_new) # sum of new = original. good


# this is a good example of how the new state specific polygon could be less
# than 8 Ha, corresponding to pond emission factor, but original polygon was
# much larger.  


# can we do group-wise operations on the name feature of the multipart polygon?
# YES!
fl.sf.c %>% filter(COMID == 13335116) %>% group_by(name) %>% # group by state
  summarise(total_area = sum(area_ha_new))

# does it work when we combine single and multipart polygons? 
# YES!
fl.sf.c %>% filter(COMID %in% c(13335116, 120049647)) %>% #pool 8 + polygon in Minnesota
                   group_by(name) %>% # group by state
  summarise(total_area = sum(area_ha_new))


```


## Define Flooded Land Type and Subtype

Per figure 7.2 in methodology, <8 ha is pond.  Canal/Ditch and inundation area are derived from FTYPE values.

```{r}
# Define size threshold for ponds.
# Probably best to remove the units attribute from the area variables.  The
# attribute carries some overhead that can be confusing.
class(fl.sf.c$area_ha_original) # units
units(fl.sf.c$area_ha_original) <- NULL
units(fl.sf.c$area_ha_new) <- NULL

fl.sf.c <- fl.sf.c %>% mutate(subtype = ifelse(area_ha_original < 8,
                                               "freshwater pond",
                                               "reservoir"),
                              subtype = ifelse(FTYPE == "CanalDitch", #get canals and ditches
                                               "canals and ditches",
                                               subtype),
                              subtype = ifelse(FTYPE == "Inundation Area",
                                               "inundation area",
                                               subtype),
                              type = ifelse(subtype %in% c("reservoir", "inundation area"),
                                            "reservoir",
                                            "other constructed waterbodies"))

```


## Set Up Time Series Infrastructure
Emissions/removals must be calculated for each year in the time series.  Reservoir age is extracted from NID.  When age not available we assume > 20.

```{r}
# Need to calculate emission separately for each year in time series
# Put copy of sf object into 31 separate list elements.  Each element represents
# one calculation year.
fl <- list(fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c,
           fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c,
           fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c,
           fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, fl.sf.c, 
           fl.sf.c, fl.sf.c, fl.sf.c)
           
names(fl) <- 1990:2020 # name each list element

# add calculation year as a column in each list element
for (i in 1: length(fl)) { # do all elements simultaneously
 fl[[i]]$calc_year = as.numeric(names(fl[i]))  
}


# Calculate waterbody age for each calculation year
# More recent years should have more waterbodies due to recent construction.
# First, how many records per list element now
lapply(fl, function(x) nrow(x)) #55597 rows

fl <- lapply(fl, function(x) # calculate age per calculation year
  x %>% mutate(age = calc_year - YEAR_COMPLETED) %>%
    # only keep reservoirs that existed in particular calc_year.  Lots
    # of systems with no age info, lets keep all of those.
  filter(age >= 0 | is.na(age)) %>% # removes years with negative age
    mutate(lu = ifelse(age >= 20 | is.na(age), #if no age, then assume old
                       "Flooded Land Remaining Flooded Land",
                       "Land Converted to Flooded Land"))) 

lapply(fl, function(x) nrow(x)) #55,597 in 2020, but only 55,137 in 1990. good
unique(fl[[29]]$lu)
table(fl[[29]]$lu)
```

## Emisssion and Removal Emission Factors

IPCC default emission factors are based on Flooded Land age, Flooded Land size, and climate zone.  Flooded Lands greater than 20 years old are considered "Flooded Lands Remaining Flooded Lands", whereas Flooded Lands less than 20 years old are classified as "Lands Converted to Flooded Lands".  

### Land Converted to Flooded Land
#### Reservoirs
The CH~4~ emission factor is greater for Land Converted to Flooded Land than for Flooded Lands Remaining Flooded Lands.  CO~2~ emissions are also estimated for this land use category, but not for Flooded Lands Remaining Flooded Lands.  Emission factors are dissagregated by the six major climate zones.

#### Other Constructed Waterbodies
No emission factors are provided for 'Other Constructed Waterbodies' in this land-use category.  IPCC guidance says to use Flooded Land Remaining Flooded Land values CH4 values.  IPCC guidance says to use use `Land Converted to Flooded Land - reservoirs` CO2 emission factors for freshwater pond CO2 emission factors, but provides no guidance for other constructed water bodies.

### Flooded Land Remaining Flooded Land
#### Reservoirs
CO~2~ emissions are not estimated for Flooded Land Remaining Flooded Land.  CH~4~ emission factors are dissagregated by the six major climate zones present in the US.  

#### Other Constructed Waterbodies
Flooded Lands less than 8 Ha are classified as freshwater ponds for this inventory and have a single emission factor.  Canals and ditches are derived from NHD FTYPE and have a singe emission factor.  No downstream emissions for this category.

## Calculate emissions
###All polygons

```{r}
# Read in emission factors
ef <- readxl::read_excel("inputData/defaultEmissionFactors.xlsx") %>%
  select(subtype, lu, climate, co2.tonnes.ha.y, ch4.tonnes.ha.y)

# record nrow of fl list prior to merge.  Should be identical after merge.
n.row.prior <- lapply(fl, function(x) nrow(x)) %>% do.call("rbind",. )

# Merge emission factors with each list element.  This takes a few minutes
fl.e <- lapply(fl, function(x)
  merge(x, ef))  

# Make sure no records were lost during merge
# LOOKS GOOD
n.row.prior == lapply(fl.e, function(x) nrow(x)) %>% do.call("rbind",. )

# Calculate emissions
# Downstream emissions are calculated as 9% of surface emissions.  Surface emissions
# should reflect sum of reservoir + inundation area emissions.  Therefore
# downstream emissions should be calculated for both inundation and reservoir.
fl.e <- lapply(fl.e, function(x) {
  x %>% mutate(co2.tonnes.y = area_ha_new * co2.tonnes.ha.y,
               ch4.surface.tonnes.y = area_ha_new * ch4.tonnes.ha.y,
               ch4.dn.tonnes.y = ifelse(type == "other constructed waterbodies", # no DN for 'other'
                                        0,
                                        ch4.surface.tonnes.y * 0.09), # inundation and reservoirs
               ch4.total.tonnes.y = ch4.surface.tonnes.y + ch4.dn.tonnes.y)
})



```

### Aggretate as needed
#### Set up a few things
```{r}
# We want all states to have an area value for each type (res, pond, ditch), even
# if the value is 0.  Create a full matrix of type by state for joining with area calculations.
# this may not be necessary, but this way states will know their area isn't missing,
# but may have 0 for some things.

# 1. df of all states in our inventory
state.names <- us %>% st_drop_geometry() %>% select(name) %>% 
  filter(!(name %in% c("Hawaii", "Alaska", "Puerto Rico"))) # not in our inventory

# 2. vector of unique 'type' values
types <- lapply(fl.e, function(x) unique(x$subtype)) %>%
  do.call("cbind", .) %>% as.vector(.) %>% unique()

# 3. create full grid
full.state.type.grid <- expand.grid(types, state.names$name) %>% 
  rename(type = Var1, name = Var2) 

```



##### All Flooded Land Surface Area and EFs by state, climate, type, subtype, and lu
This is written out to state specific tabs in Excel file.  See 'Write to Excel' section.
```{r}
# First, write surface area and emission factor data to Excel for each state
# per Tom's request.

# Calculate area by state, subtype, climate
fl.cl.area <- lapply(fl.e, function(x) {
  # calculate area by state
  x %>% 
    st_drop_geometry() %>%
    dplyr::group_by(lu, subtype, name, climate) %>% # name = state
    summarize(area = sum(area_ha_new))  %>% # sum by group
    mutate(area = replace(area, is.na(area), 0),  # replace NA with 0
           type = ifelse(subtype %in% c("reservoir", "inundation area"), # restore type column
                         "reservoir",
                         "other constructed waterbodies"))
})

# append calculation year to the name of the area variable
for (i in 1:length(fl.cl.area)) { # for each list element
  names(fl.cl.area[[i]])[names(fl.cl.area[[i]]) == "area"] = paste0("area", names(fl.cl.area[i])) # combine "area" with list element name (which is calculation year)
}

# FL area table with climate
fl.cl.area.state.type <- fl.cl.area %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  merge(., ef %>% rename(CO2.emission.factor.tonnes.co2.ha.y = co2.tonnes.ha.y,
                         CH4.emission.factor.tonnes.ch4.ha.y = ch4.tonnes.ha.y)) %>%
  mutate(across(contains("area"), ~replace(.x, is.na(.x), 0))) %>% # replace NA with 0
  arrange(lu, name, type, subtype, climate) %>% # sort rows
  relocate(lu, name, type, subtype, climate) %>% # move columns
  as.data.frame() # remove tibble stuff, messes with writing to excel

```

##### Flooded Land Remaining Flooded Land CH4 flux National Summary Table By subtype and Flux Type
This table is written to summary tab of Excel document.  Does not appear in text.
```{r}
# National summary table for state by state Excel file
flrfl.ch4.national.subtype.l <- 
lapply(fl.e, function(x) {
  x %>% 
    st_drop_geometry() %>%
    filter(lu == "Flooded Land Remaining Flooded Land") %>%
    select(-ch4.tonnes.ha.y) %>% # remove emission factor column, makes across() below easier
    group_by(subtype) %>%
    summarise(across(contains("ch4"), ~sum(.x)/1000)) %>% # scale to ktonnes ch4
    # rename to ktonnes ch4
    rename_with(~sub(pattern = "tonnes", replacement = "ktonnes", x = .), .cols = contains("tonnes"))
})

# append calculation year to the name of the area variable
for (i in 1:length(flrfl.ch4.national.subtype.l)) { # for each list element
  # select column names containing 'ch4'
  names(flrfl.ch4.national.subtype.l[[i]])[grepl("ch4", names(flrfl.ch4.national.subtype.l[[i]]))] =
    # append name with list element name (calculation year)
    paste0(names(flrfl.ch4.national.subtype.l[[i]])[grepl("ch4", names(flrfl.ch4.national.subtype.l[[i]]))],
           names(flrfl.ch4.national.subtype.l[i])) 
}


# FLRFL national emissions table
# ch4 in ktonnes.year
flrfl.ch4.national.subtype <- flrfl.ch4.national.subtype.l %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  pivot_longer(!subtype, names_to = "flux.type", values_to = "flux") %>%
  mutate(year = substr(flux.type, 
                       start = nchar(flux.type) - 3, 
                       stop = nchar(flux.type)),
         flux.type = ifelse(grepl("dn", flux.type),
                            "downstream",
                            ifelse(grepl("surface", flux.type),
                                   "surface",
                                   ifelse(grepl("total", flux.type),
                                          "total",
                                          "oops!")))) %>%
  pivot_wider(names_from = year, values_from = flux) %>%
  arrange(desc(subtype), desc(flux.type)) %>%
  mutate(Activity = paste(subtype, flux.type) %>% # creating column to match 8/27/21 wirth e-mail
           ifelse(grepl("total", .), # if total in Activity
                  gsub(" .*$", "", .), # grab everything before first space
                  .) %>% # else dont change anything
           ifelse(grepl("surface", .),
                  "surface",
                  .) %>%
           ifelse(grepl("downstream", .),
                         "downstream",
                         .)) %>%
  relocate(Activity)

unique(flrfl.ch4.national.subtype$flux.type) # no "oops!", good
```


##### Land Converted to Flooded Land GHG flux National Summary Table By subtype and Flux Type
This table is written to summary tab of Excel document.  Does not appear in text.
```{r}
# National summary table, state by state, for Excel file
lcfl.ghg.national.subtype.l <- 
lapply(fl.e, function(x) {
  x %>% 
    st_drop_geometry() %>%
    filter(lu == "Land Converted to Flooded Land") %>%
    select(-ch4.tonnes.ha.y, -co2.tonnes.ha.y) %>% # remove emission factor column, makes across() below easier
    group_by(subtype) %>%
    summarise(across(contains("ch4"), ~sum(.x)/1000), # scale to ktonnes ch4
              co2.mmt.y = sum(co2.tonnes.y)/1000000, # scale to MMT CO2
              co2.mmtc. = (sum(co2.tonnes.y)/1000000)*(12/44)) %>% # scale to MMT CO2-C
    # rename to ktonnes
    rename_with(~sub(pattern = "tonnes", replacement = "ktonnes", x = .), .cols = contains("tonnes"))
})

# append calculation year to the name of the flux variables
for (i in 1:length(lcfl.ghg.national.subtype.l)) { # for each list element
  # select column names containing 'ch4'
  names(lcfl.ghg.national.subtype.l[[i]])[grepl(c("ch4|co2"), names(lcfl.ghg.national.subtype.l[[i]]))] =
    # append name with list element name (calculation year)
    paste0(names(lcfl.ghg.national.subtype.l[[i]])[grepl(c("ch4|co2"), names(lcfl.ghg.national.subtype.l[[i]]))],
           names(lcfl.ghg.national.subtype.l[i])) 
}


# lcfl national emissions table
# ch4 and CO2 in ktonnes.year
lcfl.ghg.national.subtype <- lcfl.ghg.national.subtype.l %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  pivot_longer(!subtype, names_to = "flux.type", values_to = "flux") %>%
  mutate(year = substr(flux.type, 
                       start = nchar(flux.type) - 3, 
                       stop = nchar(flux.type)),
         gas = ifelse(grepl("co2", flux.type),
                      "co2",
                      ifelse(grepl("ch4", flux.type),
                             "ch4", 
                             "oops")),
         units = ifelse(grepl("ktonnes", flux.type),
                        "ktonnes",
                        ifelse(grepl("mmt.", flux.type, fixed = TRUE), # fixed needed or '.' is ignored
                               "mmt",
                               ifelse(grepl("mmtc", flux.type),
                                      "mmtc",
                                      "oops!"))),
         flux.type = ifelse(grepl("dn", flux.type),
                            "downstream",
                            ifelse(grepl(c("surface|co2"), flux.type),
                                   "surface",
                                   ifelse(grepl("total", flux.type),
                                          "total",
                                          "oops!")))) %>%
  pivot_wider(names_from = year, values_from = flux) %>%
  arrange(desc(subtype), gas, desc(flux.type)) %>%
  # creating column to match 8/27/21 wirth e-mail
  mutate(Activity = paste(subtype, flux.type) %>% # piped into ifelse()
           ifelse(grepl("total", .), # if total in Activity
                  gsub(" .*$", "", .), # grab everything before first space
                  .) %>% # else dont change anything
           ifelse(grepl("surface", .),
                  "surface",
                  .) %>%
           ifelse(grepl("downstream", .),
                  "downstream",
                  .)) %>%
  relocate(Activity)

unique(lcfl.ghg.national.subtype$flux.type) # no "oops!", good
unique(lcfl.ghg.national.subtype$gas) # no "oops!", good
unique(lcfl.ghg.national.subtype$units) # no "oops!", good
```
### Write to Excel
```{r}
# Write data to Excel

# Read excel file where output should be placed.
file <- "output/outputTablesState.xlsx"
wb <- openxlsx::loadWorkbook(file)
sheets <- openxlsx::getSheetNames(file)


# SURFACE AREA AND EMISSION FACTORS BY STATE FIRST

# Sheet names states in inventory
stateNames <- data.frame(state_abbr = us %>% st_drop_geometry() %>%
                           select(name, state_abbr) %>%
                           filter(!(state_abbr %in% c("AK", "HI", "PR"))) %>%
                           select(state_abbr) %>% pull(),
                         name = us %>% st_drop_geometry() %>%
                           select(name, state_abbr) %>%
                           filter(!(state_abbr %in% c("AK", "HI", "PR"))) %>%
                           select(name) %>% pull()) %>%
  arrange(name)
  

for (i in 1:nrow(stateNames)){ # very fast
  
  sheet.i <- sheets[endsWith(sheets, stateNames$state_abbr[i])]
  
  # write FLRFL
  openxlsx::writeData(wb,
                      sheet = sheet.i,
                      x = fl.cl.area.state.type %>% 
                        filter(lu == "Flooded Land Remaining Flooded Land",
                               name == stateNames$name[i]) %>%
                        select(-contains("co2")),  
                      rowNames = FALSE, colNames = FALSE,
                      startRow = 6, startCol = 1,
                      withFilter = FALSE)
  
  # write LCFL
  openxlsx::writeData(wb,
                      x = fl.cl.area.state.type %>% 
                        filter(lu == "Land Converted to Flooded Land",
                               name == stateNames$name[i]) %>%
                        relocate(CO2.emission.factor.tonnes.co2.ha.y, 
                                 .after = CH4.emission.factor.tonnes.ch4.ha.y),  
                      sheet = sheet.i, # pull name from list
                      rowNames = FALSE, colNames = FALSE,
                      startRow = 31, # Will be below longest FLRFL table
                      startCol = 1)
  
  print(paste0("data_added-", i))
}

# Flooded Land Remaining Flooded Land National CH4 flux table
openxlsx::writeData(wb,
                    x = flrfl.ch4.national.subtype %>%
                      select(-flux.type, -subtype), 
                    sheet = "7.3.1_FLRFL_summary",
                    rowNames = FALSE, colNames = TRUE,
                      startRow = 13, 
                      startCol = 2)

# Land Converted to Flooded Land National CH4 flux table
openxlsx::writeData(wb,
                    x = lcfl.ghg.national.subtype %>%
                      filter(gas == "ch4") %>%
                      select(-flux.type, -subtype, -gas, -units),
                    sheet = "7.3.2_LCFL_summary",
                    rowNames = FALSE, colNames = TRUE,
                      startRow = 13, 
                      startCol = 2)

# Land Converted to Flooded Land National CO2 flux table
openxlsx::writeData(wb,
                    x = lcfl.ghg.national.subtype %>%
                      filter(gas == "co2", units == "mmt") %>%
                      select(-flux.type, -Activity, -gas, -units) %>%
                      rename(Activity = subtype),
                    sheet = "7.3.2_LCFL_summary",
                    rowNames = FALSE, colNames = TRUE,
                    startRow = 46, 
                    startCol = 2)

openxlsx::saveWorkbook(wb, file, overwrite = TRUE) ## save changes to excel 


### DEPRECATED------------------------
# ### Code for writing out nationally aggregated data to Excel.  This output is
# ### not required per Wirth.  Also, code written with xlsx package which
# ### can give memory issues.  Keeping this code around for now, but may delete
# ### later.
# file.nat <- "output/outputTablesNational.xlsx"
# wb.nat <- xlsx::loadWorkbook(file.nat) # load file for further processing
# sheets <- xlsx::getSheets(wb.nat)
# numberColTSC <- 36 # This setting is for objects aggregated by type, state, and climate
# numberColLTSC <- 37 # This setting is for objects aggregated by land use, type, state, and climate
# 
# 
# # numeric formatting
# dataFormatNumberD <- DataFormat("#,##0") # thousands separator, no decimals
# cslistTSC <- lapply(4:numberColTSC, function(x){CellStyle(wb.nat) + dataFormatNumberD})
# cslistLTSC <- lapply(5:numberColLTSC, function(x){CellStyle(wb.nat) + dataFormatNumberD})
# 
# # Formatting for totals row
# fillSecondary <- Fill('#ff6666','#ff6666','SOLID_FOREGROUND') #fill color
# createFonts <- function(wb) {list(data = Font(wb.nat, isBold = TRUE))} # bold font
# f <- createFonts(wb.nat) # bold font
# 
# # Add data to excel file
# # FLRFL surface area aggregated by state, climate, type, 
# addDataFrame(x = fl.cl.area.state.type %>% 
#                filter(lu == "Flooded Land Remaining Flooded Land") %>%
#                select(-lu, -contains("co2")),  
#              sheet = sheets[]$`7.3.1_FLRFL_allCalcs`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              # apply number formatting
#              colStyle = setNames(cslistTSC, 4:(numberColTSC-2))) # -2 select our lu and co2
# 
# addDataFrame(x = fl.cl.area.state.type %>% 
#                filter(lu == "Flooded Land Remaining Flooded Land")%>%
#                select_if(~is.numeric(.)) %>%
#                select(!contains("tonnes")) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.1_FLRFL_allCalcs`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(fl.cl.area.state.type %>% 
#                filter(lu == "Flooded Land Remaining Flooded Land")) + 6, # +6 space on top
#              startColumn = 4, # start under first numeric column
#              colStyle = setNames(lapply(cslistTSC, function(x){
#                x + fillSecondary + f$data}), 1:31)) # 31 colums
# 
# 
# 
# # Reset these formatting specifics for more coarsly aggregated data below
# numberCol <- 32 # all data object have type, state, and 30 years, for a total of 32 columns
# 
# # numeric formatting
# dataFormatNumberD <- DataFormat("#,##0") # thousands separator, no decimals
# cslist <- lapply(3:numberCol, function(x){CellStyle(wb.nat) + dataFormatNumberD})
# 
# # Formatting for totals row
# fillSecondary <- Fill('#ff6666','#ff6666','SOLID_FOREGROUND') #fill color
# createFonts <- function(wb.nat) {list(data = Font(wb.nat, isBold = TRUE))} # bold font
# f <- createFonts(wb.nat) # bold font
# 
# 
# # FLRFL area
# addDataFrame(x = flrfl.area.state.type,  
#              sheet = sheets[]$`7.3.1_FLRFL_area`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# addDataFrame(x = flrfl.area.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#                sheet = sheets[]$`7.3.1_FLRFL_area`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(flrfl.area.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30))
# 
# 
# # FLRFL downstream CH4
# addDataFrame(x = flrfl.dn.ch4.state.type,  
#              sheet = sheets[]$`7.3.1_FLRFL_dnCh4`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# addDataFrame(x = flrfl.dn.ch4.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.1_FLRFL_dnCh4`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(flrfl.dn.ch4.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30))
# 
# 
# # FLRFL surface CH4
# addDataFrame(x = flrfl.surface.ch4.state.type,  
#              sheet = sheets[]$`7.3.1_FLRFL_surfCh4`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# addDataFrame(x = flrfl.surface.ch4.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.1_FLRFL_surfCh4`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(flrfl.surface.ch4.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30))
# 
# 
# # FLRFL total CH4
# addDataFrame(x = flrfl.total.ch4.state.type,  
#              sheet = sheets[]$`7.3.1_FLRFL_totCh4`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# addDataFrame(x = flrfl.total.ch4.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.1_FLRFL_totCh4`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(flrfl.total.ch4.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30))
# 
# 
# # LCFL area
# addDataFrame(x = lcfl.area.state.type,  
#              sheet = sheets[]$`7.3.2_LCFL_area`,
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# addDataFrame(x = lcfl.area.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.2_LCFL_area`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(lcfl.area.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30))
# 
# 
# # LCFL downstream CH4
# addDataFrame(x = lcfl.dn.ch4.state.type,  
#              sheet = sheets[]$`7.3.2_LCFL_dnCh4`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# addDataFrame(x = lcfl.dn.ch4.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.2_LCFL_dnCh4`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(lcfl.dn.ch4.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30))
# 
# # LCFL surface CH4
# addDataFrame(x = lcfl.surface.ch4.state.type,  
#              sheet = sheets[]$`7.3.2_LCFL_surfCh4`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# addDataFrame(x = lcfl.surface.ch4.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.2_LCFL_surfCh4`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(lcfl.surface.ch4.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30))
# 
# 
# # LCFL total CH4
# addDataFrame(x = lcfl.total.ch4.state.type,  
#              sheet = sheets[]$`7.3.2_LCFL_totCh4`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist, 3:numberCol))
# 
# addDataFrame(x = lcfl.total.ch4.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#                sheet = sheets[]$`7.3.2_LCFL_totCh4`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(lcfl.total.ch4.state.type) + 6, # +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30)
# )
# 
# 
# # LCFL CO2
# addDataFrame(x = lcfl.co2.state.type,  
#              sheet = sheets[]$`7.3.2_LCFL_Co2`, # pull name from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = 6, startColumn = 1,
#              colStyle = setNames(cslist,3:numberCol))
# 
# addDataFrame(x = lcfl.co2.state.type %>% select_if(~is.numeric(.)) %>%
#                # https://stackoverflow.com/questions/28873057/sum-across-multiple-columns-with-dplyr
#                summarise(across(everything(), ~sum(., is.na(.), 0))),  # col sums
#              sheet = sheets[]$`7.3.2_LCFL_Co2`, # names are weird, pull from list
#              row.names = FALSE, col.names = FALSE,
#              startRow = nrow(lcfl.co2.state.type) + 6, #  +6 space on top
#              startColumn = 3, # start under first numeric column
#              colStyle = setNames(lapply(cslist, function(x){x + fillSecondary + f$data}), 1:30)
# )
# 
# 
# 
# #setForceFormulaRecalculation(wb,"data",TRUE)
# wb.nat$setForceFormulaRecalculation(TRUE)
# saveWorkbook(wb.nat, file.nat)





```


# Text for report
###Flooded Land Remaining Flooded Land
#### Emissions and Removals from Flooded Land Remaining Flooded Land - Reservoirs
In 2020 the conterminous United States hosted `r fl.cl.area.state.type %>% filter(lu == "Flooded Land Remaining Flooded Land", type == "reservoir") %>% select(area2020) %>% summarize(tot.area = sum(area2020)) %>% pull()` hectares of reservoirs in the Flooded Land Remaining Flooded Land category.  These reservoirs are distributed across the `r fl.e[[1]] %>% st_drop_geometry() %>% filter(lu == "Flooded Land Remaining Flooded Land", type == "reservoir") %>% summarize(climate.zones = length(unique(climate))) %>% pull()`.

#####Climate zone and Flooded lands map
```{r}
# data for US state map
us.plot <- us %>%  
  filter(!(name %in% c("Hawaii", "Alaska", "Puerto Rico")))

state.clime <- st_intersection(us.plot, climate) # clip climate map to US

ggplot() +
  geom_sf(data = state.clime, aes(fill = climate)) +
  geom_sf(data = fl$`2020` %>% filter(type == "reservoir", 
                                      lu == "Flooded Land Remaining Flooded Land"), 
          fill = "black", color = "black") +
  coord_sf(datum = NA) + # this removes grid lines.
  theme(panel.background = element_blank(), # remove grey panel background
        legend.title = element_blank()) # remove legend title

ggsave("output/figures/climateMap.tiff")
```


#####Figure::  Aggregated reservoir emissions plotted by state.
```{r}
# Calculate total reservoir CH4 emissions by state for 2020
flrfl.total.ch4.2020.reservoir <- fl.e$`2020` %>% 
  st_drop_geometry() %>% 
    filter(lu == "Flooded Land Remaining Flooded Land",
           type == "reservoir") %>%
    dplyr::group_by(name) %>% 
    summarize(ch4.total.tonnes.y = sum(ch4.total.tonnes.y, na.rm = T))  %>% # sum by group
    full_join(., state.names) %>% # expand to include every state, even if area is NA (which means 0)
    mutate(ch4.total.tonnes.y = replace(ch4.total.tonnes.y, is.na(ch4.total.tonnes.y), 0),
           ch4.total.ktonnes.y = ch4.total.tonnes.y / 1000) %>% # replace NA with 0
    arrange(name)


# add emissions data to object
us.plot.flrfl.total.ch4.2020.reservoir <- merge(us.plot, 
                                                flrfl.total.ch4.2020.reservoir) 


ggplot(us.plot.flrfl.total.ch4.2020.reservoir) +
  geom_sf(aes(fill = ch4.total.ktonnes.y)) +
  scale_fill_distiller(expression(kt~CH[4]~y^-1), 
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  theme(panel.background = element_blank())

ggsave("output/figures/FLRFL.reservoir.2020.Tch4.tiff")
```

#####TABLE:: FLRFL-reservoirs CH4 emissions by mechanism (dn, surface), type (inundation, reservoir), and state
```{r}


fl.e$`2020` %>%  
  st_drop_geometry() %>%
  filter(type == "reservoir",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(name, subtype, ch4.surface.tonnes.y, ch4.dn.tonnes.y) %>%
  group_by(name, subtype) %>%
  summarize(ch4.surface.tonnes.y = sum(ch4.surface.tonnes.y), 
            ch4.dn.tonnes.y = sum(ch4.dn.tonnes.y)) %>%
  pivot_wider(names_from = subtype, 
              values_from = c(ch4.surface.tonnes.y, ch4.dn.tonnes.y),
              values_fill = 0) %>% # replace NA with 0
  select(name, ch4.dn.tonnes.y_reservoir, ch4.surface.tonnes.y_reservoir,
         `ch4.dn.tonnes.y_inundation area`, `ch4.surface.tonnes.y_inundation area`) %>%
  mutate(ch4.dn.tonnes.y = ch4.dn.tonnes.y_reservoir + `ch4.dn.tonnes.y_inundation area`,
         ch4.surface.tonnes.y = ch4.surface.tonnes.y_reservoir + `ch4.surface.tonnes.y_inundation area`) %>%
  mutate(across(where(is.numeric), ~.x/1000)) %>% # convert to kt
  rename_with(~sub(pattern = "tonnes", replacement = "ktonnes", x = .), 
              .cols = contains("tonnes")) %>%
  write.table(., "clipboard", row.names = FALSE)

```

#####Oahe and Saskawea: surface area and CH4 flux
```{r}
# Notably, this was the case for Lakes Sakakawea Oahe in North Dakota and South Dakota border.  Combined, these two reservoirs have a surface area in excess of 
fl.e[[1]] %>%  # 1990
  st_drop_geometry() %>% 
  filter(lu == "Land Converted to Flooded Land",
         COMID %in% c(19251179, 21543470, 21541960, 
                      21529608, 21539872,120048827)) %>% # Oahe, Saskawea, Saskawea inundation area
  distinct(area_ha_original) %>% # area repeated due to multipolygons from interstection with state
  summarize(area.tot = sum(.)/1000000) %>%
  pull() # million hectares

# What year did they transfer into FLRFL
fl.e[[1]] %>%  # 1990
  st_drop_geometry() %>% 
  filter(lu == "Land Converted to Flooded Land",
         COMID %in% c(19251179, 21543470, 21541960, 
                      21529608, 21539872,120048827)) %>% # Oahe, Saskawea, Saskawea inundation area
  select(YEAR_COMPLETED) %>%
  mutate(year_to_flrfl = YEAR_COMPLETED + 21)

fl.e[[31]] %>%  #2020
  st_drop_geometry() %>% 
  filter(lu == "Flooded Land Remaining Flooded Land",
         COMID %in% c(19251179, 21543470, 21541960, 
                      21529608, 21539872,120048827)) %>% # Oahe, Saskawea, Saskawea inundation area
  summarize(ch4.total.ktonnes.y = sum(ch4.total.tonnes.y)/1000) %>%
  pull() # 15.27

15.27/(749-688) * 100 #25% of total increase from 1990 to 2005 due to these reservoirs
```


#### Methodology
Flooded land age was determined from data in the NID when available (`r dplyr::bind_rows(nav, inund, res) %>% st_drop_geometry() %>% filter(!is.na(YEAR_COMPLETED)) %>% summarize(total.n = n()) %>% pull()` out of `r dplyr::bind_rows(nav, inund, res) %>% st_drop_geometry() %>% summarize(total.n = n()) %>% pull()`).  


#####surface are of reservoirs created between 1990 and 2000
```{r}

fl.e[[31]] %>% #2020  
  st_drop_geometry() %>% 
  as_tibble() %>%
  filter(YEAR_COMPLETED >= 1990, YEAR_COMPLETED < 2020) %>%
  distinct(COMID, .keep_all = TRUE) %>% # possilbe duplication from intersection with state climate
  distinct(area_ha_original, .keep_all = TRUE) %>% #possilbe duplication from intersection with state climate
  summarize(area.tot = sum(area_ha_original)/1000000) %>%
  pull() # million hectares
```

#####TABLE:: National Flooded Land Area for Reservoirs and Inundation Areas
```{r}
fl.cl.area.state.type %>%
filter(type == "reservoir",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(subtype, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(subtype) %>%
    summarize(across(contains("area"), ~sum(.)/1000000)) %>%
  arrange(desc(subtype))
```

#####TABLE:: Flooded Land Area for Reservoirs and Inundation Areas by State
```{r}
fl.cl.area.state.type %>%
filter(type == "reservoir",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(name, type, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(name) %>% # not differentiating by res vs inundation, table too long for report
    summarize(across(contains("area"), ~sum(.)/1000000)) %>%
  write.table(., "clipboard", row.names = FALSE)
  

```

#### Other Constructed Waterbodies (Freshwater Ponds, Saline Ponds, Canals and Ditches)
In 2019 the conterminous United States hosted `r fl.cl.area.state.type %>% filter(lu == "Flooded Land Remaining Flooded Land", type == "other constructed waterbodies") %>% group_by(subtype) %>% summarize(tot.area = sum(area2020))`  hectares of freshwater pond and `canals and ditches` surface area, respectively, in the Flooded Land Remaining Flooded Land category.    

##### Emissions and Removals from Flooded Land Remaining Flooded Land - Other Constructed Waterbodies
###### TABLE:: National level CH4 flux table
National level CH4 flux tables in the text are pulled from 'tables' tab of Excel file.  Table reconstructed below as a check against Excel calcs.
```{r}
# FLRFL-other constructed waterbodies ch4 total emissions table National
# fluxes reported in ktonnes per year
flrfl.ch4.national.subtype.l %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  select(subtype, contains("ch4.total")) %>% # only interested in total for other...
  filter(subtype %in% c("canals and ditches", "freshwater pond")) %>%
  pivot_longer(!subtype, names_to = "flux.type", values_to = "flux") %>%
  mutate(year = substr(flux.type, 
                       start = nchar(flux.type) - 3, 
                       stop = nchar(flux.type))) %>%
  select(-flux.type) %>%
  pivot_wider(names_from = year, values_from = flux) 
```
###### TABLE:: State level CH4 flux table
State level CH4 flux tables are not compiled in Excel.  Table written to clipboard below, pasted and formated in inventoryReportTablesFormattedFromR.xlsx, then pasted into report table.
```{r}
# FLRFL-other constructed waterbodies ch4 total emissions table by state
# fluxes reported in ktonnes per year

# STEP 1: STATE BY STATE TABLE
flrfl.ocwb.ch4.state <- fl.e$`2020` %>%  
  st_drop_geometry() %>%
  filter(type == "other constructed waterbodies",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(name, subtype, ch4.total.tonnes.y) %>%
  group_by(name, subtype) %>%
  summarize(ch4.total.tonnes.y = sum(ch4.total.tonnes.y)) %>%
  pivot_wider(names_from = subtype, 
              values_from = ch4.total.tonnes.y,
              values_fill = 0) %>% # replace NA with 0
  mutate(total = `canals and ditches` + `freshwater pond`) %>%
  mutate(across(where(is.numeric), ~.x/1000)) # tonnes to ktonnes


# STEP 2: NATIONAL TOTALS
flrfl.ocwb.ch4.totals <- fl.e$`2020` %>%  
  st_drop_geometry() %>%
  filter(type == "other constructed waterbodies",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(subtype, ch4.total.tonnes.y) %>%
  group_by(subtype) %>%
  summarize(ch4.total.tonnes.y = sum(ch4.total.tonnes.y)) %>%
  pivot_wider(names_from = subtype, 
              values_from = ch4.total.tonnes.y,
              values_fill = 0) %>% # replace NA with 0
  mutate(total = `canals and ditches` + `freshwater pond`,
         name = "TOTAL") %>% # to match formatting in Word table
  mutate(across(where(is.numeric), ~.x/1000)) # tonnes to ktonnes

# STEP 3: MERGE STATE TABLE WITH TOTALS
rbind(flrfl.ocwb.ch4.state, flrfl.ocwb.ch4.totals) %>% 
  write.table(., "clipboard", row.names = FALSE)
```

###### FIGURE:: Emissions by state
Over 50% of CH4 from canals and ditches is from Louisiana.
```{r}

# add emissions data to object
us.plot.flrfl.total.ch4.2020.ocwb <- merge(us.plot, 
                                                flrfl.ocwb.ch4.state) 


p1 <- ggplot(us.plot.flrfl.total.ch4.2020.ocwb) +
  geom_sf(aes(fill = `canals and ditches`)) +
  scale_fill_distiller(expression(kt~CH[4]~y^-1), 
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(A.~CH[4]~Emissions~from~Canals~and~Ditches)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))



p2 <- ggplot(us.plot.flrfl.total.ch4.2020.ocwb) +
  geom_sf(aes(fill = `freshwater pond`)) +
  scale_fill_distiller(expression(kt~CH[4]~y^-1), 
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(B.~CH[4]~Emissions~from~Freshwater~Ponds)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))

g <- plot_grid(p1, p2, nrow=1, ncol=2)


ggsave("output/figures/FLRFL.ocwb.2020.Tch4.tiff", g, width = 7, height =2, units = "in" )
```


#### Methodology

##### Area
For the year 2020, this inventory contains `r fl.cl.area.state.type  %>%  filter(lu == "Flooded Land Remaining Flooded Land", subtype == "freshwater pond") %>% summarize(area2020 = sum(area2020)) %>% pull()` ha of freshwater ponds and `r fl.cl.area.state.type  %>%  filter(lu == "Flooded Land Remaining Flooded Land", subtype == "canals and ditches") %>% summarize(area2020 = sum(area2020)) %>% pull()` ha of canals and ditches in Flooded Land Remaining Flooded Land.

######TABLE:: National Flooded Land Area for Other Constructed Waterbodies
```{r}
fl.cl.area.state.type %>%
filter(type == "other constructed waterbodies",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(subtype, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(subtype) %>%
    summarize(across(contains("area"), sum)) %>%
  arrange(subtype) %>%
  write.table(., "clipboard", row.names = FALSE)
```
Canals and ditches in the contimernos U.S. are most abundant in the Gulf Coast states and California (Fig. x-xxA.). Louisiana contains `r fl.cl.area.state.type %>% filter(subtype == "canals and ditches", lu == "Flooded Land Remaining Flooded Land", name == "Louisiana") %>% summarize(area2020 = sum(area2020)) %>% pull() / fl.cl.area.state.type %>% filter(subtype == "canals and ditches", lu == "Flooded Land Remaining Flooded Land") %>% summarize(area2020 = sum(area2020)) %>% pull()` percent of all US canals and ditches. Texas has the greatest surface area of freshwater ponds, equivalent to   `r fl.cl.area.state.type %>% filter(subtype == "freshwater pond", lu == "Flooded Land Remaining Flooded Land", name == "Texas") %>% summarize(area2020 = sum(area2020)) %>% pull() / fl.cl.area.state.type %>% filter(subtype == "freshwater pond", lu == "Flooded Land Remaining Flooded Land") %>% summarize(area2020 = sum(area2020)) %>% pull()`.

######FIGURE:: Flooded Land Area for Other Constructed Waterbodies by State

```{r}
# construct other constructed waterbodies surface area table
flrfl.ocwb.area <- fl.cl.area.state.type %>%
  filter(type == "other constructed waterbodies",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(name, subtype, area2020) %>%
  group_by(name, subtype) %>% # not differentiating by pond vs canals, table too long for report
  summarize(across(contains("area"), ~sum(.))) %>%
  pivot_wider(names_from = subtype, 
              values_from = area2020,
              values_fill = 0)


# add emissions data to object
us.plot.flrfl.area.2020.ocwb <- merge(us.plot, flrfl.ocwb.area) 


p1 <- ggplot(us.plot.flrfl.area.2020.ocwb) +
  geom_sf(aes(fill = `canals and ditches`)) +
  scale_fill_distiller("hectares", 
                       labels=function(x) format(x, big.mark = ",", scientific = FALSE),
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(A.~Area~of~Canals~and~Ditches)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))



p2 <- ggplot(us.plot.flrfl.area.2020.ocwb) +
  geom_sf(aes(fill = `freshwater pond`)) +
  scale_fill_distiller("hectares", 
                       labels=function(x) format(x, big.mark = ",", scientific = FALSE),
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(B.~Area~of~Freshwater~Ponds)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))


g <- plot_grid(p1, p2, nrow=1, ncol=2)


ggsave("output/figures/FLRFL.ocwb.2020.area.tiff", g)
```

######TABLE:: Flooded Land Area for Other Constructed Waterbodies by State
```{r}
fl.cl.area.state.type %>%
filter(type == "other constructed waterbodies",
         lu == "Flooded Land Remaining Flooded Land") %>%
  select(name, type, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(name) %>% # not differentiating by pond vs canals, table too long for report
    summarize(across(contains("area"), ~sum(.))) %>%
  write.table(., "clipboard", row.names = FALSE)
  

```
###Land Converted to Flooded Land
####Emissions and Removals from Land Converted to Flooded Land - Reservoirs
In 2020 the conterminous United States hosted `r fl.cl.area.state.type %>% filter(lu == "Land Converted to Flooded Land", type == "reservoir") %>% select(area2020) %>% summarize(tot.area = sum(area2020)) %>% pull()` hectares of reservoirs in the Flooded Land Remaining Flooded Land category.  These reservoirs are distributed across the `r fl.e[[31]] %>% st_drop_geometry() %>% filter(lu == "Land Converted to Flooded Land", type == "reservoir") %>% summarize(climate.zones = length(unique(climate))) %>% pull()`.

#####Climate zone and Flooded lands map
```{r}
# data for US state map
us.plot <- us %>%  
  filter(!(name %in% c("Hawaii", "Alaska", "Puerto Rico")))

state.clime <- st_intersection(us.plot, climate) # clip climate map to US

ggplot() +
  geom_sf(data = state.clime, aes(fill = climate)) +
  geom_sf(data = fl$`2020` %>% filter(type == "reservoir", 
                                      lu == "Land Converted to Flooded Land"), 
          fill = "black", color = "black") +
  coord_sf(datum = NA) + # this removes grid lines.
  theme(panel.background = element_blank(), # remove grey panel background
        legend.title = element_blank()) # remove legend title

ggsave("output/figures/climateMapLCFL.tiff")
```

Methane and CO2 flux from reservoirs and inundated areas in Minnesota was nearly 10-fold greater than any other state (Figure 2, Table x-x).  This is attributed to `r  fl.e$`2020` %>% st_drop_geometry() %>% filter(lu == "Land Converted to Flooded Land", type == "reservoir", name == "Minnesota") %>% select(name, COMID, contains("area"), contains("year", ignore.case = TRUE)) %>% summarize(n = length(unique(COMID))) ` dams which impound `r  fl.e$`2020` %>% st_drop_geometry() %>% filter(lu == "Land Converted to Flooded Land", type == "reservoir", name == "Minnesota") %>% select(name, COMID, contains("area"), contains("year", ignore.case = TRUE)) %>% distinct(COMID, .keep_all = TRUE) %>% summarize(area = sum(area_ha_new))` ha of water, `r 51787 / fl.e$`2020` %>% st_drop_geometry() %>% filter(lu == "Land Converted to Flooded Land", type == "reservoir", name == "Minnesota") %>% select(name, COMID, contains("area"), contains("year", ignore.case = TRUE)) %>% distinct(COMID, .keep_all = TRUE) %>% summarize(area = sum(area_ha_new)) %>% pull()` percent of which is Mille Lacs lake.  North Dakota is the second largest source of CO2 and CH4 from reservoirs and inundated areas in LCFL,  `r fl.e$`2020` %>% st_drop_geometry() %>% filter(lu == "Land Converted to Flooded Land", type == "reservoir", name == "North Dakota") %>% select(name, COMID, contains("area"), contains("year", ignore.case = TRUE)) %>% slice_max(area_ha_new) %>% select(area_ha_new) %>% pull() / fl.e$`2020` %>% st_drop_geometry() %>% filter(lu == "Land Converted to Flooded Land", type == "reservoir", name == "North Dakota") %>% summarize(area=sum(area_ha_new)) %>% pull() `%  percent of LCFL-reservoir surface area in North Dakota is attributed to Devils Lake.  


#####FIGURE::  Aggregated reservoir emissions plotted by state.
```{r}
# Calculate total reservoir CH4 and CO2 emissions by state for 2020
lcfl.ghg.2020.reservoir <- fl.e$`2020` %>% 
  st_drop_geometry() %>% 
    filter(lu == "Land Converted to Flooded Land",
           type == "reservoir") %>%
    dplyr::group_by(name) %>% 
    summarize(ch4.total.tonnes.y = sum(ch4.total.tonnes.y, na.rm = T),
              co2.tonnes.y = sum(co2.tonnes.y, na.rm = T))  %>% # sum by group
    full_join(., state.names) %>% # expand to include every state, even if area is NA (which means 0)
    mutate(ch4.total.tonnes.y = replace(ch4.total.tonnes.y, is.na(ch4.total.tonnes.y), 0), # replace NA with 0
           ch4.total.ktonnes.y = ch4.total.tonnes.y / 1000,
           co2.tonnes.y = replace(co2.tonnes.y, is.na(co2.tonnes.y), 0), # replace NA with 0
           co2.ktonnes.y = co2.tonnes.y / 1000) %>% 
    arrange(name)


# add emissions data to object
us.plot.lcfl.ghg.2020.reservoir <- merge(us.plot, 
                                                lcfl.ghg.2020.reservoir) 


p1 <- ggplot(us.plot.lcfl.ghg.2020.reservoir) +
  geom_sf(aes(fill = ch4.total.ktonnes.y)) +
  scale_fill_distiller(expression(kt~CH[4]~y^-1), 
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(A.~CH[4]~Flux~from~Reservoirs~and~Inundation~Areas)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))


p2 <- ggplot(us.plot.lcfl.ghg.2020.reservoir) +
  geom_sf(aes(fill = co2.ktonnes.y)) +
  scale_fill_distiller(expression(kt~CO[2]~y^-1), 
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(B.~CO[2]~Flux~from~Reservoirs~and~Inundation~Areas)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))


g <- plot_grid(p1, p2, nrow=1, ncol=2)


ggsave("output/figures/LCFL.reservoirs.2020.ch4.co2.tiff", g, width = 7, height =2, units = "in")

```

#####TABLE:: LCFL-reservoirs CH4 and CO2 emissions by mechanism (dn, surface), type (inundation, reservoir), and state
```{r}
#written to clipboard and pasted into word table

# ktons for CH4 and CO2
fl.e$`2020` %>%  
  st_drop_geometry() %>%
  filter(type == "reservoir",
         lu == "Land Converted to Flooded Land") %>%
  select(name, subtype, ch4.surface.tonnes.y, ch4.dn.tonnes.y, co2.tonnes.y) %>%
  group_by(name, subtype) %>%
  summarize(ch4.surface.tonnes.y = sum(ch4.surface.tonnes.y), 
            ch4.dn.tonnes.y = sum(ch4.dn.tonnes.y),
            co2.tonnes.y = sum(co2.tonnes.y)) %>%
  pivot_wider(names_from = subtype, 
              values_from = c(ch4.surface.tonnes.y, ch4.dn.tonnes.y, co2.tonnes.y),
              values_fill = 0) %>% # replace NA with 0
  full_join(., state.names) %>% # include every state, even if area is NA (which means 0)
  mutate(across(everything(), ~replace_na(.x, 0))) %>% # replace NA with 0
  select(name, ch4.dn.tonnes.y_reservoir, ch4.surface.tonnes.y_reservoir,
         `ch4.dn.tonnes.y_inundation area`, `ch4.surface.tonnes.y_inundation area`,
         co2.tonnes.y_reservoir, `co2.tonnes.y_inundation area`) %>%
  mutate(ch4.dn.tonnes.y = ch4.dn.tonnes.y_reservoir + 
           `ch4.dn.tonnes.y_inundation area`,
         ch4.surface.tonnes.y = ch4.surface.tonnes.y_reservoir + 
           `ch4.surface.tonnes.y_inundation area`,
         co2.tonnes.y = co2.tonnes.y_reservoir + `co2.tonnes.y_inundation area`) %>%
  mutate(across(where(is.numeric), ~.x/1000)) %>%
  rename_with(~gsub("tonnes", "ktonnes", .x), contains("tonnes")) %>%
  arrange(name) %>%
  relocate(name,
           ch4.dn.ktonnes.y_reservoir,
           ch4.surface.ktonnes.y_reservoir,
           co2.ktonnes.y_reservoir,
           `ch4.dn.ktonnes.y_inundation area`,
           `ch4.surface.ktonnes.y_inundation area`,
           `co2.ktonnes.y_inundation area`,
           ch4.dn.ktonnes.y,
           ch4.surface.ktonnes.y,
           co2.ktonnes.y) %>%
  write.table(., "clipboard", row.names = FALSE)

```



#### Methodology
##### Area estimates
Flooded land age was determined from data in the NID when available (`r dplyr::bind_rows(nav, inund, res) %>% st_drop_geometry() %>% filter(!is.na(YEAR_COMPLETED)) %>% summarize(total.n = n()) %>% pull()` out of `r dplyr::bind_rows(nav, inund, res) %>% st_drop_geometry() %>% summarize(total.n = n()) %>% pull()`).  



#####surface are of Oahe and Saskawea
```{r}
# Notably, this was the case for Lakes Sakakawea Oahe in North Dakota and South Dakota border.  Combined, these two reservoirs have a surface area in excess of 
fl.e[[1]] %>%  
  st_drop_geometry() %>% 
  filter(lu == "Land Converted to Flooded Land",
         COMID %in% c(19251179, 21543470, 21541960, 
                      21529608, 21539872,120048827)) %>% # Oahe, Saskawea, Saskawea inundation area
  distinct(area_ha_original) %>% # area repeated due to multipolygons from interstection with state
  summarize(area.tot = sum(.)/1000000) %>%
  pull() # million hectares

# What year did they transfer into FLRFL
fl.e[[1]] %>%  # 1990
  st_drop_geometry() %>% 
  filter(lu == "Land Converted to Flooded Land",
         COMID %in% c(19251179, 21543470, 21541960, 
                      21529608, 21539872,120048827)) %>% # Oahe, Saskawea, Saskawea inundation area
  select(YEAR_COMPLETED) %>%
  mutate(year_to_flrfl = YEAR_COMPLETED + 21)
```

#####TABLE:: National Flooded Land Area for Reservoirs and Inundation Areas in LCFL
The data generated below are pasted into the appropriate table in the report.
```{r}
fl.cl.area.state.type %>%
filter(type == "reservoir",
         lu == "Land Converted to Flooded Land") %>%
  select(subtype, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(subtype) %>%
    summarize(across(contains("area"), ~sum(.)/1000)) %>%
  arrange(desc(subtype))
```

#####FIGURE:: dams betwwen 1990 and 2000
```{r}
# Lots of screwing around with .pgn, .tiff, ggsave, etc to get this to look good in .doc


tiff("output/figures/newDams.tiff", res = 800, compression = "lzw", width = 4.77/1.8, height = 4.99/2, units = "in")

fl.e[[31]] %>% #2020  
  st_drop_geometry() %>% 
  as_tibble() %>%
  filter(YEAR_COMPLETED >= 1990) %>%
  distinct(COMID, .keep_all = TRUE) %>% # possilbe duplication from intersection with state climate
  distinct(area_ha_original, .keep_all = TRUE) %>% #possilbe duplication from intersection with state climate
group_by(YEAR_COMPLETED) %>%
  summarize(n_year = n()) %>%
  ggplot(., aes(YEAR_COMPLETED, n_year)) +
  geom_point() +
  geom_line(color = "steelblue") +
  ylab("New dams") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90),
        panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()) +
  xlim(1990, 2020)

dev.off()

```


#####surface ares of North Dakota reservoirs (LCFL) in 1990
```{r}
# Notably, this was the case for Lakes Sakakawea Oahe in North Dakota and South Dakota border.  Combined, these two reservoirs have a surface area in excess of 
fl.e[[1]] %>%  
  st_drop_geometry() %>% 
  filter(lu == "Land Converted to Flooded Land",
         COMID %in% c(19251179, 21543470, 21541960, 
                      21529608, 21539872,120048827)) %>% # Oahe, Saskawea, Saskawea inundation area
  distinct(area_ha_original) %>% # area repeated due to multipolygons from interstection with state
  summarize(area.tot = sum(.)/1000000) %>%
  pull() # million hectares
```

#####TABLE:: Flooded Land Area for LCFL Reservoirs and Inundation Areas by State
```{r}
# paste into Word table
fl.cl.area.state.type %>%
filter(type == "reservoir",
         lu == "Land Converted to Flooded Land") %>%
  select(name, type, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(name) %>% # not differentiating by res vs inundation, table too long for report
    summarize(across(contains("area"), ~sum(.)/1000)) %>% #thousands of hectares
   full_join(., state.names) %>%
   mutate(across(everything(), ~replace_na(.x, 0))) %>% # replace NA with 0
  arrange(name) %>%
  write.table(., "clipboard", row.names = FALSE)
  

```

#### Other Constructed Waterbodies (Freshwater Ponds, Saline Ponds, Canals and Ditches)
Activity data on pond salinity is not uniformly available for the conterminous U.S. and all `r fl.cl.area.state.type %>% filter(lu == "Land Converted to Flooded Land", type == "other constructed waterbodies") %>% group_by(subtype) %>% summarize(tot.area = sum(area2019))` ha of ponds in the inventory are assumed to be freshwater.   

##### Emissions and Removals from Land Converted to Flooded Land - Other Constructed Waterbodies
###### TABLE:: National level CH4 flux table
National level GHG flux tables in the text are pulled from 'tables' tab of Excel file.  Table reconstructed below as a check against Excel calcs.
```{r}
# LCFL-other constructed waterbodies total GHG emissions table National


# CH4 table first
lcfl.ghg.national.subtype.l %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  select(subtype, contains("ch4.total")) %>% # only interested in total for other...
  filter(subtype %in% c("canals and ditches", "freshwater pond")) %>%
  pivot_longer(!subtype, names_to = "flux.type", values_to = "flux") %>%
  mutate(year = substr(flux.type, 
                       start = nchar(flux.type) - 3, 
                       stop = nchar(flux.type))) %>%
  select(-flux.type) %>%
  pivot_wider(names_from = year, values_from = flux) 


# CO2 table next
lcfl.ghg.national.subtype.l %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  select(subtype, contains("co2.mmt.")) %>% # only interested in total for other...
  filter(subtype %in% c("canals and ditches", "freshwater pond")) %>%
  pivot_longer(!subtype, names_to = "flux.type", values_to = "flux") %>%
  mutate(year = substr(flux.type, 
                       start = nchar(flux.type) - 3, 
                       stop = nchar(flux.type))) %>%
  select(-flux.type) %>%
  pivot_wider(names_from = year, values_from = flux) 
```

###### TABLE:: State level GHG flux table
State level GHG flux tables are not compiled in Excel.  Table written to clipboard below, pasted and formated in inventoryReportTablesFormattedFromR.xlsx, then pasted into report table.
```{r}
# LCFL-other constructed waterbodies GHG total emissions table by state

# STEP 1: STATE BY STATE TABLE
lcfl.ocwb.ghg.state <- fl.e$`2020` %>%  
  st_drop_geometry() %>%
  filter(type == "other constructed waterbodies",
         lu == "Land Converted to Flooded Land") %>%
  select(name, subtype, contains("tonnes.y")) %>%
  group_by(name, subtype) %>%
  summarize(ch4.total.tonnes.co2.eq.y = sum(ch4.total.tonnes.y) * 25,
            co2.tonnes.y = sum(co2.tonnes.y)) %>%
  pivot_wider(names_from = subtype, 
              values_from = c(ch4.total.tonnes.co2.eq.y, co2.tonnes.y),
              values_fill = 0) %>% # replace NA with 0
  mutate(total = `ch4.total.tonnes.co2.eq.y_freshwater pond` + 
           `co2.tonnes.y_freshwater pond`) %>%
  full_join(., state.names) %>%
  arrange(name) %>%
  mutate(across(where(is.numeric), ~replace_na(., 0)))


# STEP 2: NATIONAL TOTALS
lcfl.ocwb.ghg.totals <- fl.e$`2020` %>%  
  st_drop_geometry() %>%
  filter(type == "other constructed waterbodies",
         lu == "Land Converted to Flooded Land") %>%
  select(subtype, contains("tonnes.y")) %>%
  group_by(subtype) %>%
  summarize(ch4.total.tonnes.co2.eq.y = sum(ch4.total.tonnes.y) * 25,
            co2.tonnes.y = sum(co2.tonnes.y)) %>%
  pivot_wider(names_from = subtype, 
              values_from = c(ch4.total.tonnes.co2.eq.y, co2.tonnes.y),
              values_fill = 0) %>% # replace NA with 0
    mutate(total = `ch4.total.tonnes.co2.eq.y_freshwater pond` + 
           `co2.tonnes.y_freshwater pond`) %>%
  mutate(name = "TOTAL") %>% # to match formatting in Word table
  relocate(name)


# STEP 3: MERGE STATE TABLE WITH TOTALS
rbind(lcfl.ocwb.ghg.state, lcfl.ocwb.ghg.totals) %>% 
  # IPCC required formatting.  No values meet criteria, so not
  # actually needed now.
  mutate(across(where(is.numeric), ~ifelse(.x > 0 & .x < 0.05,
                                           "+", 
                                           .x))) %>%
  write.table(., "clipboard", row.names = FALSE)
```

###### FIGURE:: Emissions by state

```{r}

# add emissions data to object
us.plot.lcfl.total.ghg.2020.ocwb <- merge(us.plot, 
                                                lcfl.ocwb.ghg.state) 


p1 <- ggplot(us.plot.lcfl.total.ghg.2020.ocwb) +
  geom_sf(aes(fill = `co2.tonnes.y_freshwater pond`)) +
  scale_fill_distiller(expression(tonnes~CO[2]~Eq.~y^-1), 
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(~A.~CO[2]~Emissions~from~Freshwater~Ponds)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))



p2 <- ggplot(us.plot.lcfl.total.ghg.2020.ocwb) +
  geom_sf(aes(fill = `ch4.total.tonnes.co2.eq.y_freshwater pond`)) +
  scale_fill_distiller(expression(tonnes~CO[2]~Eq.~y^-1), 
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(B.~CH[4]~Emissions~from~Freshwater~Ponds)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))

# having trouble with ggsave
tiff("output/figures/LCFL.ocwb.2020.ghg.tiff", res = 800, compression = "lzw", width = 4.77*2, height = 4.49*2, units = "in")

plot_grid(p1, p2, nrow=1, ncol=2)

dev.off()

```


#### Methodology

##### Area
For the year 2020, this inventory contains `r fl.cl.area.state.type  %>%  filter(lu == "Land Converted to Flooded Land", subtype == "freshwater pond") %>% summarize(area2020 = sum(area2020)) %>% pull()` ha of freshwater ponds and `r fl.cl.area.state.type  %>%  filter(lu == "Land Converted to Flooded Land", subtype == "canals and ditches") %>% summarize(area2020 = sum(area2020)) %>% pull()` ha of canals and ditches in Flooded Land Remaining Flooded Land.

######TABLE:: National Flooded Land Area for Other Constructed Waterbodies
```{r}
fl.cl.area.state.type %>%
filter(type == "other constructed waterbodies",
         lu == "Land Converted to Flooded Land") %>%
  select(subtype, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(subtype) %>%
    summarize(across(contains("area"), sum)) %>%
  arrange(subtype) %>%
  write.table(., "clipboard", row.names = FALSE)
```
Canals and ditches in the contimernos U.S. are most abundant in the Gulf Coast states and California (Fig. x-xxA.). Louisiana contains `r fl.cl.area.state.type %>% filter(subtype == "canals and ditches", lu == "Flooded Land Remaining Flooded Land", name == "Louisiana") %>% summarize(area2020 = sum(area2020)) %>% pull() / fl.cl.area.state.type %>% filter(subtype == "canals and ditches", lu == "Flooded Land Remaining Flooded Land") %>% summarize(area2020 = sum(area2020)) %>% pull()` percent of all US canals and ditches. Texas has the greatest surface area of freshwater ponds, equivalent to   `r fl.cl.area.state.type %>% filter(subtype == "freshwater pond", lu == "Flooded Land Remaining Flooded Land", name == "Texas") %>% summarize(area2020 = sum(area2020)) %>% pull() / fl.cl.area.state.type %>% filter(subtype == "freshwater pond", lu == "Flooded Land Remaining Flooded Land") %>% summarize(area2020 = sum(area2020)) %>% pull()`.

######FIGURE:: Flooded Land Area for Other Constructed Waterbodies by State

```{r}
# construct other constructed waterbodies surface area table
lcfl.ocwb.area <- fl.cl.area.state.type %>%
  filter(type == "other constructed waterbodies",
         lu == "Land Converted to Flooded Land") %>%
  select(name, subtype, area2020) %>%
  group_by(name, subtype) %>% # not differentiating by pond vs canals, table too long for report
  summarize(across(contains("area"), ~sum(.))) %>%
  pivot_wider(names_from = subtype, 
              values_from = area2020,
              values_fill = 0) %>%
  full_join(., state.names) %>%
  arrange(name) %>%
  mutate(across(where(is.numeric), ~replace_na(., 0)))


# add emissions data to object
us.plot.lcfl.area.2020.ocwb <- merge(us.plot, lcfl.ocwb.area) 


ggplot(us.plot.lcfl.area.2020.ocwb) +
  geom_sf(aes(fill = `freshwater pond`)) +
  scale_fill_distiller("hectares", 
                       labels=function(x) format(x, big.mark = ",", scientific = FALSE),
                       palette = "Blues", direction = 1) +
  coord_sf(datum = NA) + # this removes grid lines.
  ggtitle(expression(~Area~of~Freshwater~Ponds)) +
  theme(panel.background = element_blank(),
        title = element_text(size = 8))

ggsave("output/figures/LCFL.ocwb.2020.area.tiff")
```

######TABLE:: Flooded Land Area for Other Constructed Waterbodies by State
Table written to clipboard, pasted and formatted in Excel, then pasted into Word.  Yuck!
```{r}

fl.cl.area.state.type %>%
filter(type == "other constructed waterbodies",
         lu == "Land Converted to Flooded Land") %>%
  select(name, type, matches(c("1990|2005|2016|2017|2018|2019|2020"))) %>%
  group_by(name) %>% # not differentiating by pond vs canals, table too long for report
    summarize(across(contains("area"), ~sum(.))) %>%
   full_join(., state.names) %>%
  arrange(name) %>%
  mutate(across(where(is.numeric), ~replace_na(., 0))) %>%
  write.table(., "clipboard", row.names = FALSE)
  

```


# Uncertainty analysis

### Define distributions for EFs
```{r}
# Read in raw data used to calculate Rd value used in methodology
rd <- readxl::read_excel("inputData/ipccDegassingReview.xlsx", sheet = "summary")
names(rd) = gsub(pattern = c("\\(| |#|)|/|-|\\+"), 
                 replacement = ".", x = names(rd))

# Filter out observations from Maeck et al. 2013.  These contain some outliers
# and are lock and dam systems, not reflective of most reservoir surfaces.
rd.no.maeck <- filter(rd, !grepl(pattern = "Maeck", x = rd$citation))

# visualize distribution
library(fitdistrplus)
plotdist(rd.no.maeck$Rd) # appears somewhat log-normal
descdist(rd.no.maeck$Rd, boot = 1000) # suggest beta, but this requires value 0-1

# Attempted to fit beta, lnorm, weibull, and gamma distributions, but all failed,
# likely due to zeroes in data.  Add small positive number and retry
rd <- rd.no.maeck %>%
  mutate(Rd = replace(Rd, Rd == 0, 0.00001))
descdist(rd$Rd, boot = 1000) # suggest beta
fitdist(rd$Rd, "beta") # beta requires values 0-1
flnorm <- fitdist(rd$Rd, "lnorm") # this seems to work
denscomp(flnorm) # bad fit
qqcomp(flnorm) # bad fit
cdfcomp(flnorm) # not bad
ppcomp(flnorm) # not bad

# Generate simulated data using fitted distribution and compare to original data
simData <- rlnorm(100, meanlog = flnorm$estimate[[1]], sdlog = flnorm$estimate[[2]])
data <- data.frame(rd = c(rd$Rd, simData), source = c(rep("ipcc", length(rd$Rd)), rep("sim", 100)))
# the fit looks OK.  
ggplot(data, aes(x=rd, color = source)) +
  geom_histogram() 
# but when used in uncertainty simulation generates much too large numbers.
# how about triangle distribution as discussed in IPCC 2006 CH.3
library(triangle)
triangle::rtriangle(n = 100, a = 0.05, b = 0.22, c = 0.09)# 2019, table 7.1
## view the distribution
tri <- rtriangle(n = 10000, a = 0.05, b = 0.22, c = 0.09)
hist(tri, breaks=100, main="Triangle Distribution", xlab="x")
# triangle distribution also generates far too large numbers in simulation

# How about truncated log normal?
library(EnvStats)
EnvStats::rlnormTrunc(100, 
                      meanlog = flnorm[1]$estimate[[1]], 
                      sdlog = flnorm[1]$estimate[[2]], 
                      min = 0.05, max = 0.22) %>% summary()
# still too big.
# can I define a log-normal distribution that approximates what is reported in 
# IPCC 2019 Table 7.10?  After trying all these variations, sim0.085 was the
# only one that produced a confidence interval containing the mean.
sim1.3 <- rlnorm(100, meanlog = log(0.09), sdlog = log(1.3))
sim1.4 <- rlnorm(100, meanlog = log(0.09), sdlog = log(1.4))
sim1.5 <- rlnorm(100, meanlog = log(0.09), sdlog = log(1.5))
sim1.6 <- rlnorm(100, meanlog = log(0.09), sdlog = log(1.6))
sim0.085 <- rlnorm(100, meanlog = log(0.085), sdlog = log(1.5))
summary(sim1.3);summary(sim1.4);summary(sim1.5);summary(sim1.6)
summary(sim0.085)




# Read in emission factors
ef.error <- readxl::read_excel("inputData/defaultEmissionFactors.xlsx") %>%
  # 95% CI EF for ponds is asymmetrical around the mean, causing the 95% CI
  # of total emissions to not include the mean.  Here I'm expanding the CI
  # of the EF to force symmetry around mean.
  # Calculating CH4 emission factor standard deviation from 95% CI and n reported in guidance.
  # This will allow parameter distribution to be defined using rnorm, the preferred IPCC method.
  # No N reported for CO2, so using uniform distribution.
  # https://stats.stackexchange.com/questions/30402/how-to-calculate-mean-and-standard-deviation-in-r-given-confidence-interval-and
  mutate(ch4.tonnes.ha.y.upr = replace(ch4.tonnes.ha.y.upr, 
                                       subtype == "freshwater pond",
                                       0.248),
         ch4.sd = ((ch4.tonnes.ha.y.upr - ch4.tonnes.ha.y)/sqrt(n.ch4)) * 1.96)

# record nrow of fl list prior to merge.  Should be identical after merge.
n.row.prior <- lapply(fl[c("1990", "2020")], nrow) #55137 and 55597

# Merge emission factors with 2020 area inventory.
fl.error <- lapply(fl[c("1990", "2020")], function(x) {
  merge(st_drop_geometry(x), ef.error)  # lose geometry to reduce memory
})

# Make sure no records were lost during merge
# LOOKS GOOD
unlist(n.row.prior) == unlist(lapply(fl.error, nrow))

# Calculate emissions

###PICK UP HERE.  ADD 1990 DATA!!!
fl.error.1990 <- list()
fl.error.2020 <- list()
set.seed(3452) # make it reproducible
for (i in 1:1000) { # 1000 simulations takes 2 mintus50 seconds.  10,000 < 10 minutes, but freezes computer
  poo <- lapply(fl.error, function(x) { x %>%
    mutate(co2.tonnes.ha.y = runif(nrow(x), co2.tonnes.ha.y.lwr, co2.tonnes.ha.y.upr),
           ch4.tonnes.ha.y = rnorm(nrow(x), mean = ch4.tonnes.ha.y, sd = ch4.sd),
           # using rlnorm for downstream, see above.  mean of 0.085 needed to get lower
           # confidence interval less than mean estimate.  true mean is 0.09
           dn.ef = rlnorm(nrow(x), meanlog = log(0.085), sdlog = log(1.5)),
           area_ha_new = runif(nrow(x), #15% error in area
                               min = area_ha_new - (area_ha_new*0.15), 
                               max = area_ha_new + (area_ha_new*0.15)),
           co2.tonnes.y = area_ha_new * co2.tonnes.ha.y,
           ch4.surface.tonnes.y = area_ha_new * ch4.tonnes.ha.y,
           ch4.dn.tonnes.y = ifelse(type == "other constructed waterbodies", # no DN for 'other'
                                    0,
                                    ch4.surface.tonnes.y * dn.ef),
           ch4.total.tonnes.y = ch4.surface.tonnes.y + ch4.dn.tonnes.y)
  })
  fl.error.1990[[i]] <- poo$`1990`
  fl.error.2020[[i]] <- poo$`2020`
}



fl.error.list <- list()
set.seed(3452) # make it reproducible
for (i in 1:1000) { # 1000 simulations takes 50 seconds.  10,000 < 10 minutes, but freezes computer
  poo <- fl.error %>% 
    mutate(co2.tonnes.ha.y = runif(nrow(fl.error), co2.tonnes.ha.y.lwr, co2.tonnes.ha.y.upr),
           ch4.tonnes.ha.y = rnorm(nrow(fl.error), mean = ch4.tonnes.ha.y, sd = ch4.sd),
           # using rlnorm for downstream, see above.  mean of 0.085 needed to get lower
           # confidence interval less than mean estimate.  true mean is 0.09
           dn.ef = rlnorm(nrow(fl.error), meanlog = log(0.085), sdlog = log(1.5)),
           area_ha_new = runif(nrow(fl.error), #15% error in area
                               min = area_ha_new - (area_ha_new*0.15), 
                               max = area_ha_new + (area_ha_new*0.15)),
           co2.tonnes.y = area_ha_new * co2.tonnes.ha.y,
           ch4.surface.tonnes.y = area_ha_new * ch4.tonnes.ha.y,
           ch4.dn.tonnes.y = ifelse(type == "other constructed waterbodies", # no DN for 'other'
                                    0,
                                    ch4.surface.tonnes.y * dn.ef),
           ch4.total.tonnes.y = ch4.surface.tonnes.y + ch4.dn.tonnes.y)
  
  fl.error.list[[i]] <- poo
}

# Warning message:
# Problem with `mutate()` column `co2.tonnes.ha.y`.
# i `co2.tonnes.ha.y = runif(nrow(fl.error), co2.tonnes.ha.y.lwr, co2.tonnes.ha.y.upr)`.
# i NAs produced
# expected because ef.error contains NA values for co2.tonnes.ha.y.lwr and co2.tonnes.ha.y.upr
```


### Table:: Uncertainty
```{r}
# STEP 1:  Sum emissions for each iteration of above simulation
# about 2 minutes with 1000 simulations, 
ch4.co2.uncertainty <- lapply(fl.error.list, function(x) {
  x %>% 
    st_drop_geometry() %>%
    # mutate(subtype = ifelse(subtype == "inundation area", # per Wirth, separate inundation and reservoir
    #                         "reservoir",
    #                         subtype)) %>%
    group_by(lu, subtype) %>%
    summarize(ch4.surface.mmt.co2.eq.y = (sum(ch4.surface.tonnes.y , na.rm = TRUE)/1000000)*25, # surface CH4
              ch4.dn.mmt.co2.eq.y = (sum(ch4.dn.tonnes.y, na.rm = TRUE)/1000000)*25, # downstream CH4
              ch4.total.mmt.co2.eq.y = (sum(ch4.total.tonnes.y, na.rm = T)/1000000)*25, # total CH4
              co2.mmt.co2.eq.y = sum(co2.tonnes.y, na.rm = TRUE)/1000000) %>% # total CO2
    mutate(ghg.total.mmt.co2.eq.y = co2.mmt.co2.eq.y + ch4.total.mmt.co2.eq.y)
  })

# Above calculates uncertainty by lu and subtype.  Here we calculate by lu, but aggregate
# reservoir and inundatation subtype.  This is is needed for 'total' row in table
ch4.co2.uncertainty.total <- lapply(fl.error.list, function(x) {
  x %>% 
    st_drop_geometry() %>%
    mutate(subtype = ifelse(subtype == "inundation area", # combine for total row
                            "reservoir",
                            subtype)) %>%
    group_by(lu, subtype) %>%
    summarize(ch4.surface.mmt.co2.eq.y = (sum(ch4.surface.tonnes.y , na.rm = TRUE)/1000000)*25, # surface CH4
              ch4.dn.mmt.co2.eq.y = (sum(ch4.dn.tonnes.y, na.rm = TRUE)/1000000)*25, # downstream CH4
              ch4.total.mmt.co2.eq.y = (sum(ch4.total.tonnes.y, na.rm = T)/1000000)*25, # total CH4
              co2.mmt.co2.eq.y = sum(co2.tonnes.y, na.rm = TRUE)/1000000) %>% # total CO2
    mutate(ghg.total.mmt.co2.eq.y = co2.mmt.co2.eq.y + ch4.total.mmt.co2.eq.y)
  })

# STEP 2: COLLAPSE LIST INTO DF
# ch4.co2 uncertainty table
ch4.co2.uncertainty.table <- ch4.co2.uncertainty %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  group_by(lu, subtype) %>%
  summarize(across(everything(), list(min = min,
                                      max = max)))

ch4.co2.uncertainty.table.total <- ch4.co2.uncertainty.total %>% 
  reduce(full_join) %>% # merge all elements of list into single df.
  group_by(lu, subtype) %>%
  summarize(across(everything(), list(min = min,
                                      max = max)))

# STEP 3:  CALCULATE MEAN EMISSIONS TO COMBINE WITH UNCERTAINTY ESTIMATES
# Bring in mean flux estimates for 2020.  Reported in `Table::FLRFL-reservoirs CH4
# emissions by mechanism (dn, surface), type (inundation, reservoir), and state' above,
# but recalcualted here to merge with uncertainty results.

# ch4.co2 mean fluxes
ch4.co2.mean.table <- fl.e$`2020` %>%  
  st_drop_geometry() %>%
  # mutate(subtype = ifelse(subtype == "inundation area", # not discriminating inundation and reservoir here
  #                         "reservoir",
  #                         subtype)) %>%
  select(lu, subtype, ch4.surface.tonnes.y, ch4.dn.tonnes.y, 
         ch4.total.tonnes.y, co2.tonnes.y) %>%
  group_by(lu, subtype) %>%
  summarize(ch4.surface.mmt.co2.eq.y = (sum(ch4.surface.tonnes.y)/1000000)*25, 
            ch4.dn.mmt.co2.eq.y = (sum(ch4.dn.tonnes.y)/1000000)*25,
            ch4.total.mmt.co2.eq.y = (sum(ch4.total.tonnes.y)/1000000)*25,
            co2.mmt.co2.eq.y = sum(co2.tonnes.y)/1000000,
            ghg.total.mmt.co2.eq.y = co2.mmt.co2.eq.y + ch4.total.mmt.co2.eq.y) 


# ch4.co2 mean fluxes total!
ch4.co2.mean.table.total <- fl.e$`2020` %>%  
  st_drop_geometry() %>%
  mutate(subtype = ifelse(subtype == "inundation area", # not discriminating inundation and reservoir here
                          "reservoir",
                          subtype)) %>%
  select(lu, subtype, ch4.surface.tonnes.y, ch4.dn.tonnes.y, 
         ch4.total.tonnes.y, co2.tonnes.y) %>%
  group_by(lu, subtype) %>%
  summarize(ch4.surface.mmt.co2.eq.y = (sum(ch4.surface.tonnes.y)/1000000)*25, 
            ch4.dn.mmt.co2.eq.y = (sum(ch4.dn.tonnes.y)/1000000)*25,
            ch4.total.mmt.co2.eq.y = (sum(ch4.total.tonnes.y)/1000000)*25,
            co2.mmt.co2.eq.y = sum(co2.tonnes.y)/1000000,
            ghg.total.mmt.co2.eq.y = co2.mmt.co2.eq.y + ch4.total.mmt.co2.eq.y) 


# STEP 4: COMBINE MEAN AND UNCERTAINTY ESTIMATES
bound.perc = function(x,y){((x - y)/y) *100} # function for required fields

ch4.co2.uncertainty.mean.table <- merge(ch4.co2.uncertainty.table, ch4.co2.mean.table) %>%
  mutate(upr.perc.ch4.surface = bound.perc(ch4.surface.mmt.co2.eq.y_max, 
                                           ch4.surface.mmt.co2.eq.y),
         lwr.perc.ch4.surface = bound.perc(ch4.surface.mmt.co2.eq.y_min, 
                                           ch4.surface.mmt.co2.eq.y),
         upr.perc.ch4.dn = bound.perc(ch4.dn.mmt.co2.eq.y_max, 
                                           ch4.dn.mmt.co2.eq.y),
         lwr.perc.ch4.dn = bound.perc(ch4.dn.mmt.co2.eq.y_min, 
                                           ch4.dn.mmt.co2.eq.y),
         upr.perc.ch4.total = bound.perc(ch4.total.mmt.co2.eq.y_max, 
                                           ch4.total.mmt.co2.eq.y),
         lwr.perc.ch4.total = bound.perc(ch4.total.mmt.co2.eq.y_min, 
                                           ch4.total.mmt.co2.eq.y),
         upr.perc.co2 = bound.perc(co2.mmt.co2.eq.y_max, 
                                           co2.mmt.co2.eq.y),
         lwr.perc.co2 = bound.perc(co2.mmt.co2.eq.y_min, 
                                           co2.mmt.co2.eq.y),
         upr.perc.ghg.total = bound.perc(ghg.total.mmt.co2.eq.y_max,
                                         ghg.total.mmt.co2.eq.y),
         lwr.perc.ghg.total = bound.perc(ghg.total.mmt.co2.eq.y_min,
                                         ghg.total.mmt.co2.eq.y)) %>%
  relocate(lu, subtype, contains("surface"), contains("dn"), contains("total")) 


ch4.co2.uncertainty.mean.table.total <- merge(ch4.co2.uncertainty.table.total, ch4.co2.mean.table.total) %>%
  mutate(upr.perc.ch4.surface = bound.perc(ch4.surface.mmt.co2.eq.y_max, 
                                           ch4.surface.mmt.co2.eq.y),
         lwr.perc.ch4.surface = bound.perc(ch4.surface.mmt.co2.eq.y_min, 
                                           ch4.surface.mmt.co2.eq.y),
         upr.perc.ch4.dn = bound.perc(ch4.dn.mmt.co2.eq.y_max, 
                                           ch4.dn.mmt.co2.eq.y),
         lwr.perc.ch4.dn = bound.perc(ch4.dn.mmt.co2.eq.y_min, 
                                           ch4.dn.mmt.co2.eq.y),
         upr.perc.ch4.total = bound.perc(ch4.total.mmt.co2.eq.y_max, 
                                           ch4.total.mmt.co2.eq.y),
         lwr.perc.ch4.total = bound.perc(ch4.total.mmt.co2.eq.y_min, 
                                           ch4.total.mmt.co2.eq.y),
         upr.perc.co2 = bound.perc(co2.mmt.co2.eq.y_max, 
                                           co2.mmt.co2.eq.y),
         lwr.perc.co2 = bound.perc(co2.mmt.co2.eq.y_min, 
                                           co2.mmt.co2.eq.y),
         upr.perc.ghg.total = bound.perc(ghg.total.mmt.co2.eq.y_max,
                                         ghg.total.mmt.co2.eq.y),
         lwr.perc.ghg.total = bound.perc(ghg.total.mmt.co2.eq.y_min,
                                         ghg.total.mmt.co2.eq.y)) %>%
  relocate(lu, subtype, contains("surface"), contains("dn"), contains("total")) 


###FLRFL TABLE
# STEP 5: REPORT FOR RESERVOIR TABLE
# Reservoir and inundation area part of table
ch4.co2.uncertainty.mean.table %>% 
  filter(lu == "Flooded Land Remaining Flooded Land",
         subtype %in% c("reservoir","inundation area")) %>%
  pivot_longer(!c("lu", "subtype"), names_to = "flux.name", values_to = "flux") %>%
  mutate(surf.dn.tot = ifelse(grepl("surface", flux.name),
                              "surface",
                              ifelse(grepl("dn", flux.name),
                                     "downstream",
                                     ifelse(grepl("tot", flux.name),
                                            "total",
                                            ifelse(grepl("co2", flux.name), #Co2 is total, no downstream
                                                   "total",
                                                   "oops")))),
         flux.name = gsub(c(".surface|.dn|.total"), "", flux.name)) %>% 
  pivot_wider(names_from = flux.name, values_from = flux) %>%
  select(-contains("ghg"), -starts_with("co2"), -lwr.perc.co2, -upr.perc.co2) %>% # ghg is combined CO2 and CH4.  no CO2 for FLRFL
  filter(surf.dn.tot != "total") %>%
  arrange(desc(subtype))

#Total part of table
ch4.co2.uncertainty.mean.table.total %>% 
  filter(lu == "Flooded Land Remaining Flooded Land",
         subtype == "reservoir") %>%
  select(lu, subtype, contains("total")) %>%
  select(-contains("ghg"))
 


# STEP 6: REPORT FOR OTHER CONSTRUCTED WATERBODIES TABLE
# canals and ditches / freshwater pond rows
ch4.co2.uncertainty.mean.table %>% 
  filter(lu == "Flooded Land Remaining Flooded Land",
         subtype %in% c("canals and ditches", "freshwater pond")) %>%
  select(subtype, contains("total")) %>%
  select(-contains("ghg"))

# total row
ch4.co2.uncertainty.mean.table %>% 
  filter(lu == "Flooded Land Remaining Flooded Land",
         subtype %in% c("canals and ditches", "freshwater pond")) %>%
  select(subtype, contains("total.mmt")) %>%
  summarise(across(where(is.numeric), sum)) %>%
  mutate(upr.perc = bound.perc(ch4.total.mmt.co2.eq.y_max, 
                                           ch4.total.mmt.co2.eq.y),
         lwr.perc = bound.perc(ch4.total.mmt.co2.eq.y_min, 
                                           ch4.total.mmt.co2.eq.y))


###LCFL TABLE
# REPORT FOR RESERVOIR TABLE
# first part of table, dissagregated values
ch4.co2.uncertainty.mean.table %>% 
  filter(lu == "Land Converted to Flooded Land",
         subtype %in% c("reservoir", "inundation area")) %>% 
  pivot_longer(!c("lu", "subtype"), names_to = "flux.name", values_to = "flux") %>% 
  filter(!grepl("ch4.total", flux.name)) %>% # not reporting CH4 from dn + surface
   # distinct(flux.name) %>% print(n=Inf) %>%
  mutate(surf.dn.tot = ifelse(grepl("surface", flux.name),
                              "surface",
                              ifelse(grepl("dn", flux.name),
                                     "downstream",
                                     ifelse(grepl("^co2", flux.name), #starts with co2
                                            "surface",
                                            ifelse(grepl("ghg", flux.name),
                                                   "total", #CH4 + CO2
                                                   #all CO2 are surface
                                                   ifelse(flux.name %in% c("upr.perc.co2", "lwr.perc.co2"), 
                                                          "surface",
                                                         "oops"))))),
         flux.name = gsub(c(".surface|.dn|.total"), "", flux.name))  %>% # simplify flux name  
  pivot_wider(names_from = flux.name, values_from = flux) %>%
  select(-contains("ghg")) %>% # ghg is combined CO2 and CH4.  no CO2 for FLRFL
  filter(surf.dn.tot != "total") %>%
  arrange(desc(subtype)) %>%
  write.table(., "clipboard", row.names = FALSE)

# total part of table
ch4.co2.uncertainty.mean.table.total %>% 
  filter(lu == "Land Converted to Flooded Land",
         subtype == "reservoir") %>% # in this object, reservoir == reservoir + inundation
  select(lu, subtype, contains("ghg"))

# REPORT FOR OTHER CONSTRUCTED WATERBODIES
ch4.co2.uncertainty.mean.table %>% 
  filter(lu == "Land Converted to Flooded Land",
         subtype %in% c("freshwater pond", "canals and ditches")) %>% 
  write.table(., "clipboard", row.names = FALSE)
```





